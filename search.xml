<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux-Mem-High-Go-Trouble-Shooting]]></title>
    <url>%2F2018%2F11%2F03%2FLinux-Mem-High-Go-Trouble-Shooting%2F</url>
    <content type="text"><![CDATA[memory rise up to 90%, process was killed. the incoming throughput is normal, at 00:00 the outcoming throughput rise abruptly, which last 4 mins (23:59 – 00:03). I think it is an occasion that concurrent files uploading. establish tcp connections, which last 8 mins (23:59 – 00:07) close connections by itself, which last 4 mins (23:59 – 00:03) analysis: at the beginning of 23:59:00, 7.6k connections will be generated. At 00:00, connections start to become closed. 00:03:00 half of the connections were fully released The problem was occured after repairing a high concurrency scene problem, which the concurrent control was used to solve the problem of high memory. The above is the system status of the problem. conclusion: concurrency control is not achieved, 7.6 K connection last for 1 minutes is not the expected phenomenon, the next step is walkthrough the golang code. It is found that when the go program processes the concurrency with the channel, the asynchronous func is used between the produce and consume procudure, so that the consumption and return resource back is so quick, and the purpose of controlling concurrency cannot be achieved. Modification method: return the space after the product is actually consumed.]]></content>
  </entry>
  <entry>
    <title><![CDATA[ios11-ppt]]></title>
    <url>%2F2018%2F10%2F31%2Fios11-ppt%2F</url>
    <content type="text"><![CDATA[http://podcasts.apple.com/stanford/media/Lecture_1_Slides.pdfhttp://podcasts.apple.com/stanford/media/Lecture_2_Slides.pdfhttp://podcasts.apple.com/stanford/media/Lecture_3_Slides.pdfhttp://podcasts.apple.com/stanford/media/Lecture_4_Slides.pdfhttp://podcasts.apple.com/stanford/media/Lecture_5_Slides.pdfhttp://podcasts.apple.com/stanford/media/Lecture_6_Slides.pdf http://podcasts.apple.com/stanford/Programming_Project_1_Concentration.pdfhttp://podcasts.apple.com/stanford/Programming_Project%202_Set.pdf http://podcasts.apple.com/stanford/media/Reading_1_Intro_to_Swift.pdfhttp://podcasts.apple.com/stanford/media/Reading_2_Intro_to_Swift.pdf http://podcasts.apple.com/stanford/media/336-3367719085568248138-CS193P_F17_Reading_3.pdfhttp://podcasts.apple.com/stanford/media/309-1475895300459033080-CS193P_F17_Assignment_3.pdfhttp://podcasts.apple.com/stanford/media/309-2441628197055099936-CS193P_F17_Assignment_4.pdfhttp://podcasts.apple.com/stanford/media/308-8518403617003934463-CS193P_F17_Assignment_5.pdfhttp://podcasts.apple.com/stanford/media/307-9138746427331321981-CS193P_F17_Assignment_6.pdfhttp://podcasts.apple.com/stanford/media/320-5503734535583450465-CS193P_F17_Lecture_7.pdfhttp://podcasts.apple.com/stanford/media/335-3416648937156657194-CS193P_F17_Lecture_8.pdfhttp://podcasts.apple.com/stanford/media/332-3154341613995510587-CS193P_F17_Lecture_9.pdfhttp://podcasts.apple.com/stanford/media/322-6515997048783028736-CS193P_F17_Lecture_10.pdfhttp://podcasts.apple.com/stanford/media/317-8823617114003497609-CS193P_F17_Lecture_11.pdfhttp://podcasts.apple.com/stanford/media/306-4082649130340532415-CS193P_F17_Lecture_12.pdfhttp://podcasts.apple.com/stanford/media/323-4247208383177102782-CS193P_F17_Lecture_13.pdfhttp://podcasts.apple.com/stanford/media/322-5794459892624250293-CS193P_F17_Lecture_14.pdfhttp://podcasts.apple.com/stanford/media/522-830176750758320683-CS193P_F17_Lecture_15.pdfhttp://podcasts.apple.com/stanford/media/512-802352814004650525-CS193P_F17_Lecture_16.pdfhttp://podcasts.apple.com/stanford/media/520-5280642336803569160-CS193P_F17_Lecture_17_Slides.pdf]]></content>
      <tags>
        <tag>ios11, ppt, open.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Access restriction: The type Unsafe is not API (restriction]]></title>
    <url>%2F2018%2F10%2F25%2FAccess-restriction-The-type-Unsafe-is-not-API-restriction%2F</url>
    <content type="text"><![CDATA[Access restriction: The type xxx is not API (restrictionGenerally, we can see this in eclipse, as visit a non-public API is forbidden, such as sun.misc.Unsafe. Here I want to cancel this check temporarily.steps as follow: step1. find project properties, and click on ‘build path’ step2. double click ‘Access rules’ or just edit it step3. add a ‘rule’, fill blanks like this. project rebuild.]]></content>
      <tags>
        <tag>Access restriction The type Unsafe is not API (restriction.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-objectsize]]></title>
    <url>%2F2018%2F10%2F25%2Fjava-objectsize%2F</url>
    <content type="text"><![CDATA[One simple way to get object size1234567&lt;dependency&gt; &lt;groupId&gt;com.carrotsearch&lt;/groupId&gt; &lt;artifactId&gt;java-sizeof&lt;/artifactId&gt; &lt;version&gt;0.0.5&lt;/version&gt;&lt;/dependency&gt;System.out.println(RamUsageEstimator.sizeOf(new String("hello world!")));]]></content>
      <tags>
        <tag>java object size sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2018%2F10%2F18%2FVolatile%2F</url>
    <content type="text"><![CDATA[what kind of occasion we need to deal withconsider code behind. 12345678910111213141516public void A() throws InterruptedException &#123; for(int i = 0; i &lt; 50; i ++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i = 0; i &lt; 2; i++) &#123; ++ number; System.out.println(Thread.currentThread().getName() + " get " + number); &#125; &#125; &#125;); thread.start(); &#125; Thread.sleep(3000); System.out.println("finally " + number); &#125; finally, the result of ‘number’ is not predictable, which might be 960, 977 or 999. what volatile can guaranteeit keeps every thread get ‘global’ variable with consitent value. one more thing, ++number is not atomic, update number in multi-thread is not safe. add synchronized symbol will make it.123456789101112131415161718public void A() throws InterruptedException &#123; for(int i = 0; i &lt; 50; i ++) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i = 0; i &lt; 2; i++) &#123; synchronized (integerLock) &#123; ++ number; System.out.println(Thread.currentThread().getName() + " get " + number); &#125; &#125; &#125; &#125;); thread.start(); &#125; Thread.sleep(3000); System.out.println("finally " + number); &#125; so, synchronized can be a useable way in this occasion. compared to Optimistic Lock, synchronized cost too much, as it is a kind of Pessimistic Lock. what volatile meansn. a volatile substance; a substance that changes readily from solid or liquid to a vapor, which means somthing can be changed at anytime. As statement ‘lock’ will have bus or cache(cpu level) all to itself(core), which will influence multi-core performance. cas + volatile is a kind of Optimistic Lock, code follows. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * @ClassName: CASTest.java * @Description: TODO * * @author xiang_wang * @version V1.0 * @Date 2018年10月25日 下午3:13:08 */import java.lang.reflect.Field;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import sun.misc.Unsafe;/** * @author xiang_wang * */public class CASTest &#123; private volatile int value = 0; public int get() &#123; return value; &#125; public int increaseAndGet() throws NoSuchFieldException, SecurityException, InterruptedException &#123; while(true) &#123; int next = value + 1; if(innerCas(value, next)) &#123; return next; &#125;else &#123; System.out.println(Thread.currentThread().getName() + " wait."); Thread.sleep(100); &#125; &#125; &#125; private boolean innerCas(int before, int after) throws NoSuchFieldException, SecurityException &#123; Unsafe unsafe = getUnsafe(); return unsafe.compareAndSwapInt(this, unsafe.objectFieldOffset(CASTest.class.getDeclaredField("value")), before, after); &#125; public static Unsafe getUnsafe() &#123; try &#123; Field singletonInstanceField = Unsafe.class.getDeclaredField("theUnsafe"); singletonInstanceField.setAccessible(true); return (Unsafe) singletonInstanceField.get(null); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * @Title: main * @Description: TODO * @param: @param args * @return: void * @throws * @author xiang_wang * @Date 2018年10月25日 下午3:13:09 * @throws SecurityException * @throws NoSuchFieldException * @throws InterruptedException */ public static void main(String[] args) &#123; // TODO Auto-generated method stub CASTest casTest = new CASTest(); ExecutorService es = Executors.newFixedThreadPool(10); for(int i = 0; i &lt; 10; ++ i) &#123; es.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; while(true) &#123; System.out.println(Thread.currentThread().getName() + ":" + casTest.increaseAndGet()); Thread.sleep(100); &#125; &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;&#125; Conclusion, the method is reliable. but I am more interested in the parameters in this program. ‘Thread.sleep(100)’ statement may influence program performance, At least that’s what I believed when I wrote the program.let’s test it. In my opinion, the first statement will make increaseAndGet faster and the second will make thread competition more fiercely. when interval of retry time decrease, and competition between threads, repetition will occur, as value may have been revised by other threads.consider this two statements:12int next = value + 1; // statement 1if(innerCas(value, next)) &#123; // statement 2 In thread-1, value is 10, after statement 1, next is 11 In thread-2, value changes from 10 to 11. In thread-1, statement 2 executes, value = 11, next = 11, uhuhuh fix bug:123456int before = value; // save value for thread-xint next = before + 1; // save update value to thread-xif(innerCas(before, next)) &#123; return next;&#125;else &#123;xxx experiment result and analysis: retry/wait 50 100 200 500 1000 50 479/7422 50/10253 22/20074 22/49760 18/99256 100 60/5609 496/14968 40/20349 13/49951 23/100053 200 33/5698 103/12056 379/27471 17/50160 28/100057 500 21/6054 47/12355 18/20849 495/74570 59/102554 1000 18/6810 18/11759 23/22253 107/60574 591/159076 when wait time is as short as possible, retry time influence conflict time significantly. the lower retry time is, the more times thread try to update ‘value’.when wait time is long enough, the times become reverse related. retry and wait range from 50 to 1000 has no significant effect to total execution time, which is main related to wait time.]]></content>
      <tags>
        <tag>volatile, synchronized, java, cas.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-Handshake]]></title>
    <url>%2F2018%2F08%2F23%2FTCP-Handshake%2F</url>
    <content type="text"><![CDATA[慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 与快重传配合使用的还有快恢复算法，其过程有以下两个要点： . 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。 . 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sunday-Method-Pattern-Match]]></title>
    <url>%2F2018%2F08%2F23%2FSunday-Method-Pattern-Match%2F</url>
    <content type="text"><![CDATA[###Substr finding algorithm : Sunday 123456789101112131415161718192021222324252627282930313233343536373839404142 int sunday(char SArrary[], int iSLen, char TArrary[], int iTLen)&#123; int i = 0, j = 0, pos = -1; while (i &lt; iSLen) &#123; if (SArrary[i] == TArrary[j]) &#123; ++i; ++j; if (j == iTLen - 1) &#123; pos = i - j; &#125; &#125; else &#123; // 下一个需要比较的字符串位置next int next = iTLen - j + i; int k = iTLen - 1; for (; k &gt;= 0; --k) &#123; if (SArrary[next] == TArrary[k]) &#123; break; &#125; &#125; //找到对应的字符 if (k &gt;= 0) &#123; // i的新下标位置 i = next - k; &#125; else &#123; ++i; &#125; j = 0; &#125; &#125; return pos;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Process-communication]]></title>
    <url>%2F2018%2F08%2F23%2FProcess-communication%2F</url>
    <content type="text"><![CDATA[Process_Communication]]></content>
  </entry>
  <entry>
    <title><![CDATA[Permutation]]></title>
    <url>%2F2018%2F08%2F23%2FPermutation%2F</url>
    <content type="text"><![CDATA[###Permuation with Lua code 1234567891011121314151617181920212223242526272829function print_arr(dataArr, length) local str = ""; for i = 1, length do str = str.."\t"..tostring(dataArr[i]); end print(str)endfunction swap(data, i, index) t = data[index]; data[index] = data[i]; data[i] = t;endfunction permutation(data, sbegin, send) if sbegin == send then print_arr(data, 4); return; end for i = sbegin, send do swap(data, sbegin, i); permutation(data, sbegin + 1, send); swap(data, sbegin, i); endenddata = &#123;1, 2, 3, 4&#125;;permutation(data, 1, 4); 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;void swap(char *a, char *b)&#123; char temp = *a; *a = *b; *b = temp; temp = *a;&#125;void print_arr(string str)&#123; for (string::iterator it = str.begin(); it != str.end(); ++it)&#123; cout &lt;&lt; *it &lt;&lt; '\t'; &#125; cout &lt;&lt; endl;&#125;void permutation(string str, int begin, int end)&#123; if (begin == end)&#123; print_arr(str); &#125; for (int i = begin; i &lt; str.length(); ++i)&#123; swap(&amp;str[begin], &amp;str[i]); permutation(str, begin + 1, end); swap(&amp;str[begin], &amp;str[i]); &#125;&#125;int main()&#123; string str("abc"); permutation(str, 0, str.length() - 1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Memory-Layout-C]]></title>
    <url>%2F2018%2F08%2F23%2FMemory-Layout-C%2F</url>
    <content type="text"><![CDATA[#Memory-layout-of-variable-in-C-program As you know, variable in C can be classified info local variable, global variable. Local variable is stored in Stack, memory allocated with malloc/alloc locates in Heap. Global variable and Static Variable is located in global data area, which consists of DS and BSS. DS (data segment) contains initialized variable, which is not zero. DS can be divided into readonly DS area and read write DS area. BSS (block started by symbol) contains uninitialized variable or variable initialized with zero, which can also be divied into readonly BSS area and read write area. 2.Sample void ppp(int parameter) { return; } int main() { ppp(12); return 0;} REG BEGIN PUSH EBP MOV EBP, ESPEBP 0036FD88 0036FD88 0036FD74 main inESP 0036FD78 0036FD74 0036FD74 REG BEGIN PUSH EBP MOV EBP, ESPEBP 0036FD74 0036FD74 0036FC9C ppp inESP 0036FCA0 0036FC9C 0036FC9C REG BEGIN MOV ESP, EBP POP EBPEBP 0036FC9C 0036FC9C 0036FD74 ppp returnESP 0036F9D0 0036FC9C 0036FCA0 REG BEGIN MOV ESP, EBP POP EBPEBP 0036FD74 0036FD74 0036FD88 main returnESP 0036FD74 0036FD74 0036FD78 Before the program enter main procudure, EBP is 0x0036FD88, so this is the Base Address of current Call Frame, ESP is bigger than EBP, I think all of us can undersand this in X86 Cpu architecture. Now, we enter main, I think I should save the Base Address, right now. As we know, Context should be saved and recovered when key operations begins and stops. So 0x0036FD88 is save to stack, then ESP is decreased to 0x0036FD74. And the same time, EBP is decreased to ESP (0x0036FD84).]]></content>
  </entry>
  <entry>
    <title><![CDATA[LinkReverse]]></title>
    <url>%2F2018%2F08%2F23%2FLinkReverse%2F</url>
    <content type="text"><![CDATA[####Link Reverse 123456789101112131415161718192021222324252627Node * reverse_link(Node *cur)&#123; if(cur == NULL)&#123; return cur; &#125; if(cur-&gt;next == NULL)&#123; return cur; &#125; Node *tmp = reverse_link(cur-&gt;next); cur-&gt;next-&gt;next = cur; cur-&gt;next = NULL; return tmp;&#125;Node * reverse_link_loop(Node *cur)&#123; Node *pre = NULL; Node *next= NULL; while(cur)&#123; next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2018%2F08%2F23%2FLCS%2F</url>
    <content type="text"><![CDATA[###LCS Problem 1234567891011121314151617181920212223242526int getLcs(string a, string b) &#123; int lengthA = a.length() + 1, lengthB = b.length() + 1; vector&lt;vector&lt;char&gt; &gt; matrix; matrix.resize((lengthA)); for (int i = 0; i &lt; lengthA; ++i) &#123; matrix[i].resize(lengthB); &#125; int max_pos = -1, max_val = -1; for (int i = 1; i &lt; lengthA; ++i) &#123; for (int j = 1; j &lt; lengthB; ++j) &#123; if (a[i - 1] == b[j - 1]) &#123; matrix[i][j] = matrix[i - 1][j - 1] + 1; if (max_val &lt; matrix[i][j]) &#123; max_val = matrix[i][j]; max_pos = i; &#125; &#125; else &#123; matrix[i][j] = max(matrix[i - 1][j], matrix[i][j - 1]); &#125; &#125; &#125; return max_pos;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[i-and-i]]></title>
    <url>%2F2018%2F08%2F23%2Fi-and-i%2F</url>
    <content type="text"><![CDATA[Generally, we use operator ++ to increase variable, especially in loop.raw datatype situation We can using ++i and i++ equally. Translating the two command into assembly language, firstly i++, a = i++; 1234567891011121300B61AC3 mov eax,dword ptr [i] 00B61AC6 mov dword ptr [a],eax 00B61AC9 mov ecx,dword ptr [i] 00B61ACC add ecx,1 00B61ACF mov dword ptr [i],ecx++i can be expressed as follow, b = ++i; 00B61AD2 mov eax,dword ptr [i] 00B61AD5 add eax,1 00B61AD8 mov dword ptr [i],eax 00B61ADB mov ecx,dword ptr [i] 00B61ADE mov dword ptr [b],ecx Obviously, they cost time equally. Now, we consider the other situation.user-defined datatype situation Considering class INTEGER, 1234567891011121314151617181920212223template &lt;class T&gt;class INTEGER&#123; T value; public: INTEGER(T intVal)&#123; value = intVal; &#125; INTEGER()&#123; value = 1; &#125; INTEGER&amp; operator ++()&#123; value += 1; return *this; &#125; INTEGER operator ++(int)&#123; INTEGER tempInteger(value); value ++; return tempInteger; &#125; void print_val()&#123; cout &lt;&lt; hex &lt;&lt; "0x" &lt;&lt; value &lt;&lt; endl; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dynamic-Programming]]></title>
    <url>%2F2018%2F08%2F23%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[Definition(DP):dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions. The next time the same subproblem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time at the expense of a modest expenditure in storage space. 母牛问题：初始时间只有一头母牛，第二年开始每只成熟的母牛都会产下一头小母牛，一头小母牛话费3年成熟且可以再生下小母牛；求解第n年总母牛头数。S(n) = S(n - 1) + S(n - 3)S(1) = 1S(2) = 2S(3) = 3 Fibonacci数列问题：从第三项开始每一项等于前两项的和。S(n) = S(n - 1) + S(n - 2)S(1) = 1S(2) = 1 以上两个问题均可以用递归和根据公式用循环的方法来计算，时间复杂度分别为2^n和n, 以斐波那契额问题为例，代码如下： 1234567891011121314151617181920212223242526272829//java version//recursivepublic static int getFibnacciRecurse(int n)&#123; if(n &lt; 1)&#123; return 0; &#125;else if(n == 1 || n == 2)&#123; return 1; &#125; return getFibonacciRecurse(n - 1) + getFibonacciRecurse(n - 2);&#125;//java version//looppublic static int getFibonacciLoop(int n)&#123; int m1 = 1, m2 = 1; int index = 3, tmp = 0; while(index &lt;= n)&#123; tmp = m1 + m2; m1 = m2; m2 = tmp; index++; &#125; return tmp;&#125; 利用矩阵计算方法，为了更快的计算考虑到A(n) = A(n - 1) + A(n - 2), 右侧可以写成矩阵相乘的形式： 对上式可以进一步变形，成： 重复使用此公式，可以得到： 计算结果，快速幂计算方法：首先考虑计算10^15，15二进制为00001111，当计算10^1之后其结果可以用来计算10^2，因此10^4，10^8也可以通过一次乘法计算出来；通过这种方式可以在log(n)的时间复杂度上计算出矩阵的幂。以下为快速矩阵方式计算斐波那契额数列第n项代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//java version//quick matrix multi of pow exppublic static long[][] MatrixPowerSpeed(long[][] matrix, int pow)&#123; long[][] tmp = matrix; long[][] res = new long[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix.length; i ++)&#123; res[i][i] = 1; &#125; while(pow != 0)&#123; if ((pow &amp; 1) != 0) &#123; res = Matrix.MatrixMulti(res, tmp); &#125; tmp = Matrix.MatrixMulti(tmp, tmp); pow = pow &gt;&gt; 1; &#125; return res; &#125;//basic two matrix multipublic static long[][] MatrixMulti(long[][] matrix1, long[][] matrix2)&#123; int matrix1RowLen = matrix1.length; int matrix1ColumnLen = matrix1[0].length; int matrix2RowLen = matrix2.length; int matrix2ColumnLen = matrix2[0].length; if (matrix1ColumnLen != matrix2RowLen) &#123; System.out.println("matrix multi condition not met!"); &#125; long[][] res = new long[matrix1RowLen][matrix2ColumnLen]; for(int i = 0; i &lt; matrix1RowLen; i++)&#123; for(int j = 0; j &lt; matrix2ColumnLen; j++)&#123; res[i][j] = 0; for(int k = 0; k &lt; matrix1ColumnLen; k ++)&#123; res[i][j] += matrix1[i][k] * matrix2[k][j]; &#125; &#125; &#125; return res;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[DeadLoop]]></title>
    <url>%2F2018%2F08%2F23%2FDeadLoop%2F</url>
    <content type="text"><![CDATA[###How to write simple deadloop, check following. while(true){} .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90 _main: ## @main .cfi_startproc BB#0:pushq %rbp Lcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp movl $0, -4(%rbp)LBB0_1: ## =&gt;This Inner Loop Header: Depth=1 jmp LBB0_1 .cfi_endproc ## -- End function As we can see, there is no condition judgement after LBB0_1. Now check this, LBB0_1: ## =&gt;This Inner Loop Header: Depth=1 xorl %eax, %eax movb %al, %cl testb $1, %cl jne LBB0_2 jmp LBB0_3LBB0_2: ## in Loop: Header=BB0_1 Depth=1 jmp LBB0_1LBB0_3: xorl %eax, %eax popq %rbp retq .cfi_endprocLBB0_2 is used to execute next loop, if exit condition meets, jmp LBB0_3 will be executed. for(;;){} int main(){ for(int i = 0; i &lt; 10; i++){ i += 2; } return 0; } .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90 _main: ## @main .cfi_startproc BB#0:pushq %rbp Lcfi0: .cfi_def_cfa_offset 16Lcfi1: .cfi_offset %rbp, -16 movq %rsp, %rbpLcfi2: .cfi_def_cfa_register %rbp movl $0, -4(%rbp) movl $0, -8(%rbp)LBB0_1: ## =&gt;This Inner Loop Header: Depth=1 cmpl $10, -8(%rbp) jge LBB0_4 BB#2: ## in Loop: Header=BB0_1 Depth=1movl -8(%rbp), %eax addl $2, %eax movl %eax, -8(%rbp) BB#3: ## in Loop: Header=BB0_1 Depth=1movl -8(%rbp), %eax addl $1, %eax movl %eax, -8(%rbp) jmp LBB0_1 LBB0_4: xorl %eax, %eax popq %rbp retq .cfi_endproc ## -- End function Firstly, i is initialized with 0, then condition judgement is executed in LBB0_1, if condition meets, goto LBB0_4, else BB#2 and BB#3 will be executed. As wrote before, if condition judgement is not provided, the next step is jmp exit. labelThis is the most basic ways with label, which is common in ASM.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Basic-Sorting-Algorithm]]></title>
    <url>%2F2018%2F08%2F23%2FBasic-Sorting-Algorithm%2F</url>
    <content type="text"><![CDATA[0.1.2.?2. quicksort 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* input: arr: array for type int * low: index of first element in array high: index of last element in arrray output: arr return: the last pivotkey index prerequisites: none */int partition(int arr[], int low, int high)&#123; int pivotkey = arr[low]; int index = 0; int temp = 0; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; arr[high] &gt;= pivotkey) high--; temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; while(low &lt; high &amp;&amp; arr[low] &lt;= pivotkey) low++; temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; &#125; arr[low] = pivotkey; for(index = 0; index &lt;= 5; index++)&#123; printf("%d\t", arr[index]); &#125; printf("\n"); return low;&#125;void qsort(int arr[], int low, int high)&#123; if(low &lt; high)&#123; int retIndex = partition(arr, low, high); qsort(arr, low, retIndex - 1); qsort(arr, retIndex + 1, high); &#125;&#125;]]></content>
  </entry>
</search>
